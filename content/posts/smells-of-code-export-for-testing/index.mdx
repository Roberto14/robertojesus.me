---
title: Export a function for unit testing
slug: "/smells-of-code-export-for-testing"
date: 2022-03-22
tags:
    - smells of code
    - javascript
    - unit testing
    - software engineering
---
import SequenceNavigation from '../../../src/components/SequenceNavigation'
import sequence from '../smells-of-code/sequence'

On the Series of Smells of Code, I bring you a topic which is many times
unnoticed or neglected by developers in a daily basis, and I truly believe
most of us have done or still do this **pattern** on daily basis.

The **pattern** I'm referring to is the export for unit testing
purposes. Usually if you export a function from your module just for testing,
something is probably wrong and smelling.

### Why is it wrong?
Ideally, your module (eg. ES Modules) will export
a set of functions or methods that represent its signature or public API. The first problem
occurs right here, when exporting a private member of the module to be easier to unit test,
you are turning this private member into a public one right away.
This member can then be used by the client in ways you haven't thought of!
It clearly rises red flags as both your client code and module will be more prone to errors and security flaws.
As an overall, the cons will overweight the pros of exporting something private just to unit testing purposes.

//todo set right pattern references

### What alternatives do I have?
First and from now on, I'm going to call this practise an anti-pattern since it violates
the rules of patterns (//todo: set rigth pattern).
There is also no silver bullet or a single **pattern** or way to fix this **anti-pattern**.
Each use case is unique and has its owns business requirements and complexity. Nevertheless,
the aim for refactoring should be focused on Single Responsibility Principle (SRT) and
//todo: patterns set before

<blockquote sx={{ fontSize: "1.5em" }}>
All units of a modular system must do a single job only, and do it right!
</blockquote>

### How do I refactor the anti-pattern?
As rule of thumb, when I face such need of exporting a private function just to
make my life easier on testing it, I ask myself the following questions:

##### 1. Can I cover a private function by consuming the public api?
Providing distinct inputs to the module's public api can be enough to cover private/internal functions.

##### 2. Does this function really belongs to this module?
If I can't cover the private function, should it belong to somewhere else or even become a module itself?
I can be the client of this module.

##### 3. Can a private function be refactored to be public?
Does it provide useful functionality, or is it safe to be exported?

##### 4. Should I consider to use rewire technique?
Using rewire technique if I still need to export a private function or just go back and start from 1.
Check internals in deno docs.

### Examples of concerns

In the following example, a ES module purpose is to provide two members, to add and remove elements from breadcrumbs:

```javascript
const SEPARATOR = '>';
let currentPath = '';

const withSeparator = (path) => ` ${SEPARATOR} ${path}`;
const setNewValue = (value) => `${currentPath}${value}`;

export const addElement = (newElement, separator = false) => {
    if (separator) {
        setNewValue(withSeparator(newElement))
    } else {
        setNewValue(newElement)
    }
}

// eg another public method would be
export const removeLastElement = () => { /* implementation */}
```

In this example, we don't want to export `withSeparator` as it's a module private member.
The way we will test it is just by calling `addElement` with separator flag set as true.
The public member will cover the internal code needed.

Although, there is no big risk in exporting the `withSeparator` as it is a pure function,
if you export `setNewValue` then it's a whole new story. This one mutates data and if it's
wrongly used by a client, it could break when calling another public function like the `removeElement`.

### Thoughts

A good software design takes account the implementation of unit tests and make sure the code is
easy to test. That doesn't mean to export private code, it means we export a good public api
that it's easy to test.

Regardless of some techniques or technologies favor and accept exporting private members
(sometimes called **internals**, see 4.), in my humble opinion, it brings more risks than benefits specially for
big codebases where the complexity is considerably bigger.

I hope this article helped you to understand the main issue and gave you hints on how to improve your code.
Please tweet me and share your feedback so that we can learn together.

##### References:
1. [Applying SOLID To React](https://medium.com/docler-engineering/applying-solid-to-react-ca6d1ff926a4)

<SequenceNavigation sequence={sequence} slug='/smells-of-code-php-if-condition' />







